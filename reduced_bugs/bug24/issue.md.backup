I am using Openllet to decide the consistency of an ontology and found an example where an exception occurs. Here is a minimal example. 

- Ontology in functional syntax:
```
Prefix(:=<http://www.example.org/reasonerTester#>)
Prefix(rdfs:=<http://www.w3.org/2000/01/rdf-schema#>)

Ontology (
	Declaration(NamedIndividual(:a))
	Declaration(DataProperty(:dq))
	Declaration(DataProperty(:dr))
	
	
	HasKey(owl:Thing ( ) ( :dq :dr  ))
	
	EquivalentClasses( 
	    DataSomeValuesFrom(:dr rdfs:Literal) 
	    ObjectOneOf(:a) 
	    DataHasValue(:dq "s") 
	)
)

```

- The following exception is thrown when checking if the ontology is consistent:
```
Exception in thread "main" java.lang.NullPointerException: Cannot invoke "Object.equals(Object)" because the return value of "openllet.core.boxes.abox.Node.getTerm()" is null
	at openllet.core.rules.rete.JoinCondition.test(JoinCondition.java:26)
	at openllet.core.rules.rete.BetaMemoryNode.testConditions(BetaMemoryNode.java:83)
	at openllet.core.rules.rete.BetaMemoryNode.activate(BetaMemoryNode.java:73)
	at openllet.core.rules.rete.BetaNode.activateChildren(BetaNode.java:28)
	at openllet.core.rules.rete.BetaMemoryNode.activate(BetaMemoryNode.java:74)
	at openllet.core.rules.rete.BetaNode.activateChildren(BetaNode.java:28)
	at openllet.core.rules.rete.BetaMemoryNode.activate(BetaMemoryNode.java:74)
	at openllet.core.rules.rete.BetaNode.activateChildren(BetaNode.java:28)
	at openllet.core.rules.rete.BetaTopNode.activate(BetaTopNode.java:33)
	at openllet.core.rules.rete.AlphaNode.lambda$activate$1(AlphaNode.java:49)
	at java.base/java.util.ArrayList.forEach(ArrayList.java:1511)
	at openllet.core.rules.rete.AlphaNode.activate(AlphaNode.java:49)
	at openllet.core.rules.rete.AlphaEdgeNode.activate(AlphaEdgeNode.java:76)
	at openllet.core.rules.rete.AlphaNetwork.activateEdge(AlphaNetwork.java:161)
	at openllet.core.rules.ContinuousRulesStrategy.addEdge(ContinuousRulesStrategy.java:88)
	at openllet.core.tableau.completion.rule.SomeValuesRule.applySomeValuesRule(SomeValuesRule.java:189)
	at openllet.core.tableau.completion.rule.SomeValuesRule.apply(SomeValuesRule.java:60)
	at openllet.core.tableau.completion.rule.AbstractTableauRule.apply(AbstractTableauRule.java:106)
	at openllet.core.rules.ContinuousRulesStrategy.complete(ContinuousRulesStrategy.java:251)
	at openllet.core.boxes.abox.ABoxImpl.lambda$isConsistent$12(ABoxImpl.java:1417)
	at openllet.core.utils.Timers.execute(Timers.java:118)
	at openllet.core.boxes.abox.ABoxImpl.isConsistent(ABoxImpl.java:1417)
	at openllet.core.boxes.abox.ABoxImpl.isConsistent(ABoxImpl.java:1269)
	at openllet.core.KnowledgeBaseImpl.consistency(KnowledgeBaseImpl.java:1802)
	at openllet.core.KnowledgeBaseImpl.isConsistent(KnowledgeBaseImpl.java:1877)
	at openllet.core.KnowledgeBaseImplFullSync.isConsistent(KnowledgeBaseImplFullSync.java:403)
	at openllet.owlapi.PelletReasoner.isConsistent(PelletReasoner.java:1032)
```
- The problem:
Openllet infers that the ontology is inconsistent. I cross-checked the consistency with HermiT, which classified the ontology as consistent. 
- The behavior of Openllet is rather strange as restult of the consistency check seems to depend on the name of the individual in the `EquivalentClass` axiom. The ontology is correctly classified as consistent, if one uses the individual `:a` instead of `:c`. As far as I can see, there should be no difference in the behavior of the reasoner.

- For reproduction, here is the call from my program using OWL API:
```
OWLOntologyDocumentSource source = new FileDocumentSource(ontFile, new FunctionalSyntaxDocumentFormat());
OWLOntologyManager manager = OWLManager.createOWLOntologyManager();
ont = manager.loadOntologyFromOntologyDocument(source);
OWLReasoner openllet = OpenlletReasonerFactory.getInstance().createReasoner(ont);

openllet.isConsistent()
```

